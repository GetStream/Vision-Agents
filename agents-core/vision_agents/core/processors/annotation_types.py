"""
Data classes for visual annotations that can be drawn on video frames.

These annotations are typically generated by LLMs when asked to mark, circle,
highlight, or annotate objects in video. The AnnotationProcessor uses these
to draw overlays on video frames.
"""

from dataclasses import dataclass
from enum import Enum
from typing import List, Optional, Tuple


class AnnotationType(Enum):
    """Types of annotations that can be drawn."""

    BOX = "box"  # Bounding box (rectangle)
    CIRCLE = "circle"  # Circle
    POLYGON = "polygon"  # Polygon
    POINT = "point"  # Single point marker
    LABEL = "label"  # Text label
    LINE = "line"  # Line segment


@dataclass
class AnnotationStyle:
    """Visual styling for annotations."""

    color: Tuple[int, int, int] = (0, 255, 0)  # BGR format (Green default)
    thickness: int = 3
    font_scale: float = 0.6
    font_thickness: int = 2
    fill: bool = False  # Whether to fill shapes


@dataclass
class BoundingBox:
    """
    Bounding box annotation (rectangle).

    Coordinates can be in different formats:
    - [x1, y1, x2, y2]: Top-left and bottom-right corners (absolute pixels)
    - [x1, y1, w, h]: Top-left corner, width and height (absolute pixels)
    - Normalized coordinates (0-1) are also supported
    """

    x1: float
    y1: float
    x2: float  # Can also represent width if using x,y,w,h format
    y2: float  # Can also represent height if using x,y,w,h format
    label: Optional[str] = None
    confidence: Optional[float] = None
    style: Optional[AnnotationStyle] = None
    normalized: bool = False  # Whether coordinates are normalized (0-1)
    format: str = "xyxy"  # "xyxy" or "xywh"

    def to_absolute(self, frame_width: int, frame_height: int) -> "BoundingBox":
        """Convert normalized coordinates to absolute pixels."""
        if not self.normalized:
            return self

        if self.format == "xyxy":
            return BoundingBox(
                x1=int(self.x1 * frame_width),
                y1=int(self.y1 * frame_height),
                x2=int(self.x2 * frame_width),
                y2=int(self.y2 * frame_height),
                label=self.label,
                confidence=self.confidence,
                style=self.style,
                normalized=False,
                format="xyxy",
            )
        else:  # xywh
            return BoundingBox(
                x1=int(self.x1 * frame_width),
                y1=int(self.y1 * frame_height),
                x2=int(self.x2 * frame_width),
                y2=int(self.y2 * frame_height),
                label=self.label,
                confidence=self.confidence,
                style=self.style,
                normalized=False,
                format="xywh",
            )

    def get_corners(self) -> Tuple[int, int, int, int]:
        """
        Get corners in (x1, y1, x2, y2) format.

        Returns:
            (x1, y1, x2, y2): Top-left and bottom-right corners
        """
        if self.format == "xyxy":
            return (int(self.x1), int(self.y1), int(self.x2), int(self.y2))
        else:  # xywh
            return (
                int(self.x1),
                int(self.y1),
                int(self.x1 + self.x2),
                int(self.y1 + self.y2),
            )


@dataclass
class Circle:
    """Circle annotation."""

    center_x: float
    center_y: float
    radius: float
    label: Optional[str] = None
    style: Optional[AnnotationStyle] = None
    normalized: bool = False

    def to_absolute(self, frame_width: int, frame_height: int) -> "Circle":
        """Convert normalized coordinates to absolute pixels."""
        if not self.normalized:
            return self

        # For radius, use average of width and height for normalization
        avg_dim = (frame_width + frame_height) / 2
        return Circle(
            center_x=int(self.center_x * frame_width),
            center_y=int(self.center_y * frame_height),
            radius=int(self.radius * avg_dim),
            label=self.label,
            style=self.style,
            normalized=False,
        )


@dataclass
class Polygon:
    """Polygon annotation (closed shape with multiple vertices)."""

    points: List[Tuple[float, float]]  # List of (x, y) coordinates
    label: Optional[str] = None
    style: Optional[AnnotationStyle] = None
    normalized: bool = False

    def to_absolute(self, frame_width: int, frame_height: int) -> "Polygon":
        """Convert normalized coordinates to absolute pixels."""
        if not self.normalized:
            return self

        absolute_points = [
            (int(x * frame_width), int(y * frame_height)) for x, y in self.points
        ]
        return Polygon(
            points=absolute_points,
            label=self.label,
            style=self.style,
            normalized=False,
        )


@dataclass
class Point:
    """Single point marker annotation."""

    x: float
    y: float
    label: Optional[str] = None
    marker_size: int = 10
    style: Optional[AnnotationStyle] = None
    normalized: bool = False

    def to_absolute(self, frame_width: int, frame_height: int) -> "Point":
        """Convert normalized coordinates to absolute pixels."""
        if not self.normalized:
            return self

        return Point(
            x=int(self.x * frame_width),
            y=int(self.y * frame_height),
            label=self.label,
            marker_size=self.marker_size,
            style=self.style,
            normalized=False,
        )


@dataclass
class Line:
    """Line segment annotation."""

    x1: float
    y1: float
    x2: float
    y2: float
    label: Optional[str] = None
    style: Optional[AnnotationStyle] = None
    normalized: bool = False

    def to_absolute(self, frame_width: int, frame_height: int) -> "Line":
        """Convert normalized coordinates to absolute pixels."""
        if not self.normalized:
            return self

        return Line(
            x1=int(self.x1 * frame_width),
            y1=int(self.y1 * frame_height),
            x2=int(self.x2 * frame_width),
            y2=int(self.y2 * frame_height),
            label=self.label,
            style=self.style,
            normalized=False,
        )


@dataclass
class TextLabel:
    """Standalone text label annotation."""

    text: str
    x: float
    y: float
    style: Optional[AnnotationStyle] = None
    normalized: bool = False

    def to_absolute(self, frame_width: int, frame_height: int) -> "TextLabel":
        """Convert normalized coordinates to absolute pixels."""
        if not self.normalized:
            return self

        return TextLabel(
            text=self.text,
            x=int(self.x * frame_width),
            y=int(self.y * frame_height),
            style=self.style,
            normalized=False,
        )


# Union type for all annotation types
Annotation = BoundingBox | Circle | Polygon | Point | Line | TextLabel
